#pragma once
#include "Execution.hpp"

Execution* Execution::singleton = nullptr;
Execution::Encoding Execution::encoding = Execution::Encoding();

std::mutex mutex;
jobType hookOriginal;
std::queue<std::string> scriptQueue{};

auto Execution::getSingleton() -> Execution* {
	if (!singleton)
		singleton = new Execution();

	return singleton;
}

auto Execution::executeScript(std::string script, std::string chunk) -> void {
	const std::string& luaScript = Luau::compile(script, { 2, 1, 2 }, { true, false }, &this->encoding);

	if (luaScript.at(0) == 0)
		Defines::stdOut(3, luaScript.c_str() + 1);

	scriptQueue.push(luaScript);
}

auto __fastcall schedulerHook(std::uintptr_t self, std::uintptr_t _, std::uintptr_t a2) -> std::uintptr_t {
	std::unique_lock<std::mutex> guard{ mutex };

	if (!Config::RunOnScheduler)
		return 0;

	if (!scriptQueue.empty()) {
		auto taskScheduler{ TaskScheduler::getSingleton() };
		auto state{ taskScheduler->luaState };

		std::string script = scriptQueue.front();
		scriptQueue.pop();
		guard.unlock();

		static Defines::robloxFunctionType taskSpawn{};

		if (luau_load(state, "", script.c_str(), script.size(), 0) != LUA_OK) {
			Defines::stdOut(3, lua_tostring(state, -1));
			lua_pop(state, 1);
		}

		if (taskSpawn == nullptr) {
			auto thread = lua_newthread(state);

			lua_getfield(thread, -10002, xor("task"));
			lua_getfield(thread, -1, xor("spawn"));

			Closure* cl = (Closure*)lua_topointer(thread, -1);
			lua_CFunction func = cl->c.f;

			taskSpawn = reinterpret_cast<Defines::robloxFunctionType>(reinterpret_cast<std::intptr_t>(func));
			lua_settop(thread, 0);
		}

		taskSpawn(reinterpret_cast<std::uintptr_t>(state));
		lua_pop(state, 1);
	}

	return hookOriginal(self, a2);
}

auto Execution::setupHook() -> void {
	if (!Config::RunOnScheduler)
		return;

	TaskScheduler* taskScheduler{ TaskScheduler::getSingleton() };
	hookOriginal = reinterpret_cast<jobType>(taskScheduler->hookJob(schedulerHook));
};