#pragma once
#include "TaskScheduler.hpp"

TaskScheduler* TaskScheduler::singleton{ nullptr };

auto TaskScheduler::getSingleton() -> TaskScheduler* {
	if (singleton == nullptr)
		singleton = new TaskScheduler();

	return singleton;
}

auto TaskScheduler::getScheduler() -> std::uintptr_t {
	return Defines::getTaskScheduler();
}

auto TaskScheduler::getJobs(std::string_view JobName) -> std::uintptr_t {
	std::uintptr_t clientScheduler = this->getScheduler();

	std::vector<std::uintptr_t> jobs;
	std::uintptr_t* selectedJob = *reinterpret_cast<std::uintptr_t**>(clientScheduler + Offsets::Scheduler::jobStart);

	while (selectedJob != *reinterpret_cast<std::uintptr_t**>(clientScheduler + Offsets::Scheduler::jobEnd)) {
		jobs.push_back(*selectedJob);
		selectedJob += 2;
	}

	std::uintptr_t lastJob{};

	for (std::uintptr_t& job : jobs) {
		std::string* Name = reinterpret_cast<std::string*>(job + Offsets::Scheduler::jobName);

		if (*Name == JobName)
			lastJob = job;
	}

	return lastJob;
}

auto TaskScheduler::initialize() -> void {
	auto scriptjob{ this->getJobs(xor("WaitingHybridScriptsJob")) };

	if (Config::UseConsole)
		std::printf(xor("  Hooked WaitingHybridScriptsJob (0x%08x)\n"), scriptjob);

	std::intptr_t script[] = { 0, 0 };
	std::intptr_t identity{ 8 };

	using getGlobalStateType = lua_State*(__thiscall*)(std::intptr_t, std::intptr_t*, std::intptr_t*);
	getGlobalStateType getGlobalState = (getGlobalStateType)(Address::robloxGetGlobalState);

	this->scriptContext = *reinterpret_cast<std::uintptr_t*>(scriptjob + Offsets::Scheduler::scriptContext);
	this->luaState = getGlobalState(scriptContext, &identity, script);

	if (Config::UseConsole) {
		std::printf(xor("  Lua State -> 0x%08x\n"), reinterpret_cast<std::uintptr_t>(this->luaState));
		std::printf(xor("  Script Context -> 0x%08x\n"), this->scriptContext);
		std::printf(xor("  Data Model -> 0x%08x\n"), this->dataModel);
	}
}

auto TaskScheduler::hookJob(void* MethodHook) -> std::intptr_t {
	auto scriptJob{ this->getJobs(xor("WaitingHybridScriptsJob")) };

	Hook* jobHook{};

	void* jobPointer = Convert(void*, scriptJob);
	jobHook = new Hook(jobPointer);

	return Convert(std::intptr_t, jobHook->HookMethod((void*)MethodHook, 2));
}

auto TaskScheduler::getFps() -> std::double_t {
	return (1 / *reinterpret_cast<std::double_t*>(this->getScheduler() + Offsets::Scheduler::framerate));
}

auto TaskScheduler::setFps(std::double_t Cap) -> void {
	*reinterpret_cast<std::double_t*>(this->getScheduler() + Offsets::Scheduler::framerate) = (1 / Cap);
}

auto TaskScheduler::getIdentity() -> std::uint8_t {
	return *reinterpret_cast<std::uint8_t*>(*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(this->luaState) + 72) + 24); // <lua_State>->extra_space->context_level
}

auto TaskScheduler::setIdentity(std::uint8_t NewIdentity) -> void { 
	if (NewIdentity > 8 || NewIdentity < 0)
		return;

	*reinterpret_cast<std::uint8_t*>(*reinterpret_cast<std::uintptr_t*>(reinterpret_cast<std::uintptr_t>(this->luaState) + 72) + 24) = NewIdentity;

	if (Config::UseConsole)
		std::printf(xor("  Identity -> %i\n"), NewIdentity);
}