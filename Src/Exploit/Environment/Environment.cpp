#pragma once
#pragma warning(suppress : 4003)

#include "Environment.hpp"

Environment* Environment::singleton = nullptr;

auto Environment::getSingleton() -> Environment* {
	if (!singleton)
		singleton = new Environment();

	return singleton;
}

auto getProcessId(std::string_view processName) -> std::intptr_t {
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (Process32First(snapshot, &entry) == 1) {
		while (Process32Next(snapshot, &entry) == 1) {
			if (_stricmp(entry.szExeFile, processName.data()) == 0) {
				CloseHandle(snapshot);
				return entry.th32ProcessID;
			}
		}
	}

	CloseHandle(snapshot);
	return 0;
}

auto replace(std::string subject, std::string search, std::string replace) -> std::string {
	std::size_t pos{};

	while ((pos = subject.find(search, pos)) != std::string::npos) {
		subject.replace(pos, search.length(), replace);
		pos += replace.length();
	}

	return subject;
}

auto getgenv(lua_State* L) -> std::intptr_t {
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    return 1;
}

auto getreg(lua_State* L) -> std::intptr_t {
    lua_pushvalue(L, LUA_REGISTRYINDEX);
    return 1;
}

auto getrawmetatable(lua_State* L) -> std::intptr_t {
    luaL_checkany(L, 1);

    if (!lua_getmetatable(L, 1))
        lua_pushnil(L);

    return 1;
}

auto setrawmetatable(lua_State* L) -> std::intptr_t {
    luaL_checkany(L, 1);

    std::intptr_t t = lua_type(L, 2);
    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2, "nil or table expected");

    lua_settop(L, 2);
    lua_pushboolean(L, lua_setmetatable(L, 1));

    return 1;
}

auto setreadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);
    luaL_checktype(L, 2, LUA_TBOOLEAN);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = lua_toboolean(L, 2);

    return 0;
}

auto isreadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    lua_pushboolean(L, t->readonly);

    return 1;
}

auto iswriteable(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    lua_pushboolean(L, !t->readonly);

    return 1;
}

auto makereadonly(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = TRUE;

    return 0;
}

auto makewriteable(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TTABLE);

    Table* t = (Table*)lua_topointer(L, 1);
    t->readonly = FALSE;

    return 0;
}

auto getnamecallmethod(lua_State* L) -> std::intptr_t {
	if (auto namecall = L->namecall) {
		lua_pushstring(L, namecall->data);
		return 1;
	}
	return 0;
}

auto setnamecallmethod(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TSTRING);
    L->namecall = tsvalue(luaA_toobject(L, 1));

    return 0;
}

auto getfps(lua_State* L) -> std::intptr_t {
    auto taskScheduler{ TaskScheduler::getSingleton() };
    lua_pushinteger(L, taskScheduler->getFps());

    return 1;
}

auto setfps(lua_State* L) -> std::intptr_t {
	luaL_checktype(L, 1, LUA_TNUMBER);

	auto framerate = lua_tonumber(L, 1);

	if (framerate <= 0)
		return 0;

    auto taskScheduler{ TaskScheduler::getSingleton() };
    taskScheduler->setFps(framerate);

    return 1;
}

auto clonefunction(lua_State* L) -> std::intptr_t {
    luaL_checktype(L, 1, LUA_TFUNCTION);
    Closure* cl = (Closure*)lua_topointer(L, 1);

    lua_clonefunction(L, 1);

    return 1;
}

auto cloneref(lua_State* L) -> std::intptr_t {
	luaL_checktype(L, 1, LUA_TUSERDATA);

	const auto instance = uvalue(index2addr(L, 1));
	lua_newuserdatatagged(L, instance->len, instance->tag);

	const auto newInstance = uvalue(index2addr(L, -1));
	newInstance->metatable = (Table*)instance->metatable;

	*reinterpret_cast<std::uintptr_t*>(newInstance->data) = *reinterpret_cast<std::uintptr_t*>(instance->data);
	newInstance->dummy.u = instance->dummy.u;

	return 1;
}

auto compareinstances(lua_State* L) -> std::intptr_t {
	luaL_checktype(L, 1, LUA_TUSERDATA);
	luaL_checktype(L, 2, LUA_TUSERDATA);

	std::uintptr_t instanceOne = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(L, 1));
	std::uintptr_t instanceTwo = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(L, 2));

	lua_pushboolean(L, instanceOne == instanceTwo);
	return 1;
}

auto loadstring(lua_State* L) -> std::intptr_t {
    auto execution{ Execution::getSingleton() };

    const std::string script = lua_tostring(L, 1);
	const std::string chunk = luaL_optstring(L, 2, "=novaline");

    if (std::string(script).empty() || lua_type(L, 1) != LUA_TSTRING)
        return 0;

    const std::string& bytecode = Luau::compile(script, {}, {}, &execution->encoding);

    if (bytecode.at(0) == 0) {
        lua_pushnil(L);
        lua_pushstring(L, bytecode.c_str());

        return 2;
    }

    if (luau_load(L, chunk.c_str(), bytecode.c_str(), bytecode.size(), 0)) {
        lua_settop(L, 0);
        lua_pushnil(L);
        lua_pushstring(L, lua_tostring(L, -1));

        return 2;
    }

    return 1;
}

std::vector<std::string> httpCache = {};
auto httpget(lua_State* L) -> std::intptr_t {
	std::string url = lua_tostring(L, 1);
	bool doCache = luaL_optboolean(L, 2, false);

	if (std::string(url).empty() || lua_type(L, 1) != LUA_TSTRING)
		return 0;

	if (url.find("http") != 0) {
		luaL_error(L, "Invalid protocol specified (expected 'http://' or 'https://')");
		return 0;
	}

	for (auto& cache : httpCache) {
		if (cache.find(url) != std::string::npos) {
			lua_pushstring(L, cache.c_str());
			return 1;
		}
	}

	auto response = cpr::Get(
		cpr::Url{ url },
		cpr::Header{ {"User-Agent", "Roblox/WinInet"} }
	);

	if (HttpStatus::IsError(response.status_code)) {
		std::string output = std::format("Response: %s - %s\n", std::to_string(response.status_code),
			HttpStatus::ReasonPhrase(response.status_code));

		lua_pushstring(L, output.c_str());
		return 1;
	}

	if (doCache == true)
		httpCache.push_back(response.text);

	lua_pushstring(L, response.text.c_str());
	return 1;
}

auto iscclosure(lua_State* L) -> std::intptr_t {
    lua_pushboolean(L, lua_iscfunction(L, 1));
    return 1;
}

auto islclosure(lua_State* L) -> std::intptr_t {
    lua_pushboolean(L, lua_isLfunction(L, 1));
    return 1;
}

auto setidentity(lua_State* L) -> std::intptr_t {
    auto taskScheduler{ TaskScheduler::getSingleton() };
    taskScheduler->setIdentity(luaL_optinteger(L, 1, 8));

    return 1;
}

auto getidentity(lua_State* L) -> std::intptr_t {
    auto taskScheduler{ TaskScheduler::getSingleton() };
    lua_pushinteger(L, taskScheduler->getIdentity());

    return 1;
}

auto identifyexecutor(lua_State* L) -> std::intptr_t {
	lua_pushstring(L, Config::Name.c_str());
	lua_pushstring(L, Config::Version.c_str()); // I have to do this because UNC says "does not return version" :skull:

    return 1;
}

auto getexecutorname(lua_State* L) -> std::intptr_t {
	lua_pushstring(L, Config::Name.c_str());

	return 1;
}

std::map<Closure*, Closure*> newcclosureMap;
auto newcclosureHandler(lua_State* L) -> std::intptr_t {
    const auto nargs = lua_gettop(L);

    void* realClosure = reinterpret_cast<void*>(newcclosureMap.find(clvalue(L->ci->func))->second);

    if (realClosure == nullptr)
        return 0;

    L->top->value.p = realClosure;
    L->top->tt = LUA_TFUNCTION;
    L->top++;

    lua_insert(L, 1);

    const char* error;
    const auto res = lua_pcall(L, nargs, LUA_MULTRET, 0);

    if (res && res != LUA_YIELD && (error = lua_tostring(L, -1), !std::strcmp(error, "attempt to yield across metamethod/C-call boundary")))
		return lua_yield(L, 0);

    return lua_gettop(L);
}

std::intptr_t closureCount{};
auto newcclosure(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););

    if (lua_iscfunction(L, 1)) {
        lua_pushvalue(L, 1);
        return 1;
    }

    lua_ref(L, 1);
    lua_pushcclosure(L, newcclosureHandler, 0, 0);
    newcclosureMap[&luaA_toobject(L, -1)->value.gc->cl] = &luaA_toobject(L, 1)->value.gc->cl;

    return 1;
}

auto checkcaller(lua_State* L) -> std::intptr_t {
    ARG_CHECK(L, 0, 0);
    lua_pushboolean(L, (TaskScheduler::getSingleton()->getIdentity() > 3));
    return 1;
}

auto checkinstance(lua_State* L, std::intptr_t idx) -> bool {
    const char* t = luaL_typename(L, idx);
    return (strcmp(t, "Instance") == 0);
}

auto decompress(std::string bytecode) -> std::string {
	const char bytecode_magic[] = "RSB1";

	uint8_t hash_bytes[4];
	memcpy(hash_bytes, &bytecode[0], 4);

	for (std::uint8_t i = 0; i < 4; ++i) {
		hash_bytes[i] ^= bytecode_magic[i];
		hash_bytes[i] -= i * 41;
	}

	for (size_t i = 0; i < bytecode.size(); ++i)
		bytecode[i] ^= hash_bytes[i % 4] + i * 41;

	XXH32(&bytecode[0], bytecode.size(), 42);

	uint32_t data_size;
	memcpy(&data_size, &bytecode[4], 4);

	std::vector<uint8_t> data(data_size);
	ZSTD_decompress(&data[0], data_size, &bytecode[8], bytecode.size() - 8);

	return std::string(reinterpret_cast<char*>(&data[0]), data_size);
}

auto getscriptbytecode(lua_State* L) -> std::intptr_t {
	auto script = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(L, 1));

	auto class_descriptor = *reinterpret_cast<std::uintptr_t*>(script + 12);
	const auto& class_name = **reinterpret_cast<std::string**>(class_descriptor + 4);

	std::string bytecode{};

	if (class_name == "LocalScript")
		bytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<std::uintptr_t*>(script + 320) + 16);
	else
		bytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<std::uintptr_t*>(script + 292) + 16);

	auto bytecode_decompress = decompress(bytecode);

	lua_pushlstring(L, bytecode_decompress.c_str(), bytecode_decompress.size());
	return 1;
}

auto debug_getconstants(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1);

	if (!lua_isfunction(L, 1) && !lua_isnumber(L, 1)) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	lua_newtable(L);

	for (std::intptr_t i = 0; i < p->sizek; i++) {
		TValue* tval = &(k[i]);

		if (tval->tt == LUA_TFUNCTION) {
			TValue* i_o = (L->top);
			setnilvalue(i_o);
			L->top++;
		}
		else {
			TValue* i_o = (L->top);
			i_o->value = tval->value;
			i_o->tt = tval->tt;
			L->top++;
		}

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_getconstant(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 2);

	if (!lua_isfunction(L, 1) && !lua_isnumber(L, 1)) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	const std::intptr_t index = luaL_checkinteger(L, 2);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	if (!index) {
		luaL_argerror(L, 1, "constant index starts at 1");
		return 0;
	}

	if (index > p->sizek) {
		luaL_argerror(L, 1, "constant index is out of range");
		return 0;
	}

	TValue* tval = &(k[index - 1]);

	if (tval->tt == LUA_TFUNCTION) {
		TValue* i_o = (L->top);
		setnilvalue(i_o);
		L->top++;
	}
	else {
		TValue* i_o = (L->top);
		i_o->value = tval->value;
		i_o->tt = tval->tt;
		L->top++;
	}

	return 1;
}

auto debug_setconstant(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 3, 3);

	if (!lua_isfunction(L, 1) && !lua_isnumber(L, 1)) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	const std::intptr_t index = luaL_checkinteger(L, 2);

	luaL_checkany(L, 3);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	if (!index) {
		luaL_argerror(L, 1, "constant index starts at 1");
		return 0;
	}

	if (index > p->sizek) {
		luaL_argerror(L, 1, "constant index is out of range");
		return 0;
	}

	auto constant = &k[index - 1];

	if (constant->tt == LUA_TFUNCTION)
		return 0;

	const TValue* new_t = luaA_toobject(L, 3);
	constant->tt = new_t->tt;
	constant->value = new_t->value;

	return 0;
}

auto debug_getupvalues(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1);
	if (!lua_isfunction(L, 1) && !lua_isnumber(L, 1)) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else
		lua_pushvalue(L, 1);

	Closure* closure = (Closure*)lua_topointer(L, -1);
	TValue* upvalue_table = (TValue*)nullptr;

	lua_newtable(L);

	if (!closure->isC)
		upvalue_table = closure->l.uprefs;
	else if (closure->isC)
		upvalue_table = closure->c.upvals;

	for (std::intptr_t i = 0; i < closure->nupvalues; i++) {
		TValue* upval = (&upvalue_table[i]);
		TValue* top = L->top;

		top->value = upval->value;
		top->tt = upval->tt;
		L->top++;

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_getupvalue(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 2);
	if (!lua_isfunction(L, 1) && !lua_isnumber(L, 1)) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else
		lua_pushvalue(L, 1);

	const std::intptr_t index = luaL_checkinteger(L, 2);

	Closure* closure = (Closure*)lua_topointer(L, -1);
	TValue* upvalue_table = (TValue*)nullptr;

	if (!closure->isC)
		upvalue_table = closure->l.uprefs;
	else if (closure->isC)
		upvalue_table = closure->c.upvals;

	if (!index) {
		luaL_argerror(L, 1, "upvalue index starts at 1");
		return 0;
	}

	if (index > closure->nupvalues) {
		luaL_argerror(L, 1, "upvalue index is out of range");
		return 0;
	}

	TValue* upval = (&upvalue_table[index - 1]);
	TValue* top = L->top;

	top->value = upval->value;
	top->tt = upval->tt;
	L->top++;

	return 1;
}

auto debug_setupvalue(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 3, 3);
	if (!lua_isfunction(L, 1) && !lua_isnumber(L, 1)) {
		luaL_argerror(L, 1, "function or number expected");
		return 0;
	}


	const std::intptr_t index = luaL_checkinteger(L, 2);
	luaL_checkany(L, 3);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else
		lua_pushvalue(L, 1);

	Closure* closure = (Closure*)lua_topointer(L, -1);
	const TValue* value = luaA_toobject(L, 3);
	TValue* upvalue_table = (TValue*)nullptr;

	if (!closure->isC)
		upvalue_table = closure->l.uprefs;
	else if (closure->isC)
		upvalue_table = closure->c.upvals;

	if (!index) {
		luaL_argerror(L, 1, "upvalue index starts at 1");
		return 0;
	}

	if (index > closure->nupvalues) {
		luaL_argerror(L, 1, "upvalue index is out of range");
		return 0;
	}

	TValue* upvalue = (&upvalue_table[index - 1]);

	upvalue->value = value->value;
	upvalue->tt = value->tt;

	luaC_barrier(L, closure, value);
	lua_pushboolean(L, true);

	return 1;
}

auto debug_getprotos(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););

	if (lua_iscfunction(L, -1)) {
		luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
		return 0;
	}

	Closure* closure = (Closure*)lua_topointer(L, -1);

	lua_newtable(L);

	Proto* main_proto = closure->l.p;

	for (std::intptr_t i = 0; i < main_proto->sizep; i++) {
		Proto* proto_data = main_proto->p[i];
		Closure* lclosure = luaF_newLclosure(L, proto_data->nups, closure->env, proto_data);

		setclvalue(L, L->top, lclosure);
		L->top++;

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_getproto(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 2, 3);
	luaL_checktype(L, 2, LUA_TNUMBER);

	bool active = luaL_optboolean(L, 3, false);

	if (lua_isnumber(L, 1)) {
		std::intptr_t level = lua_tointeger(L, 1);

		if (level >= L->ci - L->base_ci || level < 0)
			luaL_argerror(L, 1, "stack level out of range");

		lua_Debug ar;
		lua_getinfo(L, level, "f", &ar);

		if (clvalue(reinterpret_cast<CallInfo*>(L->ci - level)->func)->isC)
			luaL_argerror(L, 1, "stack level to a cclosure, lclosure expected");
	}
	else
		lua_pushvalue(L, 1);

	if (lua_isnumber(L, -1) == FALSE && lua_isfunction(L, -1) == FALSE) {
		luaL_argerror(L, 1, "function or level expected");
		return 0;
	}

	const auto function = clvalue(luaA_toobject(L, -1));

	if (!function->isC) {
		if (active)
			lua_newtable(L);

		const auto index = lua_tointeger(L, 2);

		if (index < 1 || index > function->l.p->sizep)
			luaL_argerror(L, 2, "proto index out of range");

		const auto proto = function->l.p->p[index - 1];

		setclvalue(L, L->top, luaF_newLclosure(L, proto->nups, function->env, proto));
		L->top++;

		if (active)
			lua_rawseti(L, -2, 1);
	}
	else
		luaL_argerror(L, 1, "lclosure expected");

	return 1;
}

auto debug_getstack(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 2);
	luaL_checktype(L, 1, LUA_TNUMBER);

	const auto level = lua_tointeger(L, 1);
	const auto index = luaL_optinteger(L, 2, -1);

	if (level >= L->ci - L->base_ci || level < 0)
		luaL_argerror(L, 1, "level out of range");

	const auto frame = reinterpret_cast<CallInfo*>(L->ci - level);
	const auto top = (frame->top - frame->base);

	if (clvalue(frame->func)->isC)
		luaL_argerror(L, 1, "level points to a cclosure, lclosure expected");

	if (index == -1) {
		lua_newtable(L);

		for (std::intptr_t i = 0; i < top; i++) {
			setobj2s(L, L->top, &frame->base[i]);
			L->top++;

			lua_rawseti(L, -2, i + 1);
		}
	}
	else {
		if (index < 1 || index > top)
			luaL_argerror(L, 2, "stack index out of range");

		setobj2s(L, L->top, &frame->base[index - 1]);
		L->top++;
	}
	return 1;
}

auto debug_setstack(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 3, 3);
	luaL_checktype(L, 1, LUA_TNUMBER);
	luaL_checktype(L, 2, LUA_TNUMBER);
	luaL_checkany(L, 3);

	const auto level = lua_tointeger(L, 1);
	const auto index = lua_tointeger(L, 2);

	if (level >= L->ci - L->base_ci || level < 0)
		luaL_argerror(L, 1, "level out of range");

	const auto frame = reinterpret_cast<CallInfo*>(L->ci - level);
	const auto top = (frame->top - frame->base);

	if (clvalue(frame->func)->isC)
		luaL_argerror(L, 1, "level points to a cclosure, lclosure expected");

	if (index < 1 || index > top)
		luaL_argerror(L, 2, "stack index out of range");

	setobj2s(L, &frame->base[index - 1], luaA_toobject(L, 3));
	return 0;
}

auto debug_getinfo(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1);
	std::intptr_t level{};
	if (lua_isnumber(L, 1)) {
		level = lua_tointeger(L, 1);
		luaL_argcheck(L, level >= 0, 1, "level can't be negative");
	}
	else if (lua_isfunction(L, 1))
		level = -lua_gettop(L);
	else {
		luaL_argerror(L, 1, "function or level expected");
		return 0;
	}

	lua_Debug ar;
	if (!lua_getinfo(L, level, "sluanf", &ar))
		luaL_argerror(L, 1, "invalid level");

	lua_newtable(L);

	lua_pushstring(L, ar.source);
	lua_setfield(L, -2, "source");

	lua_pushstring(L, ar.short_src);
	lua_setfield(L, -2, "short_src");

	lua_pushvalue(L, 1);
	lua_setfield(L, -2, "func");

	lua_pushstring(L, ar.what);
	lua_setfield(L, -2, "what");

	lua_pushinteger(L, ar.currentline);
	lua_setfield(L, -2, "currentline");

	lua_pushstring(L, ar.name);
	lua_setfield(L, -2, "name");

	lua_pushinteger(L, ar.nupvals);
	lua_setfield(L, -2, "nups");

	lua_pushinteger(L, ar.nparams);
	lua_setfield(L, -2, "numparams");

	lua_pushinteger(L, ar.isvararg);
	lua_setfield(L, -2, "is_vararg");

	return 1;
}

auto debug_getregistry(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 0, 0);
	lua_pushvalue(L, LUA_REGISTRYINDEX);

	return 1;
}

auto getbase(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 0, 0);
	lua_pushnumber(L, *reinterpret_cast<std::double_t*>(Rebase(0)));

	return 1;
}

auto dumpfunction(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););
	Closure* cl = (Closure*)lua_topointer(L, 1);
	lua_CFunction closure = cl->c.f;
	std::uintptr_t address = reinterpret_cast<std::uintptr_t>(closure);
	lua_pushnumber(L, *reinterpret_cast<std::double_t*>(Unbase(address)));

	return 1;
}

auto dumpcontinuation(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););
	Closure* cl = (Closure*)lua_topointer(L, 1);
	lua_Continuation closure = cl->c.cont;
	std::uintptr_t address = reinterpret_cast<std::uintptr_t>(closure);
	lua_pushnumber(L, *reinterpret_cast<std::double_t*>(Unbase(address)));

	return 1;
}

auto compile(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 1, 1, luaL_checktype(L, 1, LUA_TSTRING););
	std::string code = lua_tostring(L, 1);
	std::string bytecode = Luau::compile(code, {}, {}, &Execution::getSingleton()->encoding);
	lua_pushlstring(L, bytecode.c_str(), bytecode.size());
	
	return 1;
}

auto gethui(lua_State* L) -> std::intptr_t {
	ARG_CHECK(L, 0, 0);

	auto taskScheduler{ TaskScheduler::getSingleton() };

	std::uint16_t oldIdentity = taskScheduler->getIdentity();
	taskScheduler->setIdentity(8);

	lua_getglobal(L, "game");
	lua_getfield(L, -1, "GetService");

	lua_getglobal(L, "game");
	lua_pushstring(L, "CoreGui");

	lua_pcall(L, 2, 1, 0);

	taskScheduler->setIdentity(oldIdentity);

	return 1;
}

auto Environment::Register(lua_State* L) -> void {
    luaL_Reg coreFunctions[] = {
		// {"SetupBridge", setupbridge},

        {"getgenv", getgenv},
        {"getreg", getreg},
        {"gethui", gethui},

        {"getrawmetatable", getrawmetatable},
        {"setrawmetatable", setrawmetatable},
        {"setreadonly", setreadonly},
        {"isreadonly", isreadonly},
        {"iswriteable", iswriteable},
        {"is_writeable", iswriteable},
        {"makereadonly", makereadonly},
        {"make_readonly", makereadonly},
        {"makewriteable", makewriteable},
        {"make_writeable", makewriteable},
        {"getnamecallmethod", getnamecallmethod}, // Broken
        {"setnamecallmethod", setnamecallmethod},

        {"newcclosure", newcclosure},
        {"iscclosure", iscclosure},
        {"islclosure", islclosure},
        {"checkcaller", checkcaller},

        {"loadstring", loadstring}, // Broken
        {"HttpGet", httpget},

		{"getidentity", getidentity},
		{"getthreadidentity", getidentity},
		{"getthreadcontext", getidentity},
        {"setidentity", setidentity},
        {"setthreadidentity", setidentity},
        {"setthreadcontext", setidentity},

        {"identifyexecutor", identifyexecutor},
        {"getexecutorname", getexecutorname},

        {"getfpscap", getfps},
        {"setfpscap", setfps},

        {"clonefunction", clonefunction},
        {"clonefunc", clonefunction},
        {"cloneref", cloneref},

        {"compareinstances", compareinstances},

        {"getscriptbytecode", getscriptbytecode},

		{"dumpfunction", dumpfunction},
		{"dumpcontinuation", dumpcontinuation},

        {nullptr, nullptr},
    };

    lua_pushvalue(L, LUA_GLOBALSINDEX);
    luaL_register(L, nullptr, coreFunctions);
    lua_settop(L, -(1) - 1);

	// Debug table
	lua_newtable(L);

	lua_pushcclosure(L, debug_getconstant, "debug.getconstant", 0);
	lua_setfield(L, -2, "getconstant");

	lua_pushcclosure(L, debug_getconstants, "debug.getconstants", 0);
	lua_setfield(L, -2, "getconstants");

	lua_pushcclosure(L, debug_getinfo, "debug.getinfo", 0);
	lua_setfield(L, -2, "getinfo");

	lua_pushcclosure(L, debug_getproto, "debug.getproto", 0);
	lua_setfield(L, -2, "getproto");

	lua_pushcclosure(L, debug_getprotos, "debug.getprotos", 0);
	lua_setfield(L, -2, "getprotos");

	lua_pushcclosure(L, debug_getstack, "debug.getstack", 0);
	lua_setfield(L, -2, "getstack");

	lua_pushcclosure(L, debug_getupvalue, "debug.getupvalue", 0);
	lua_setfield(L, -2, "getupvalue");

	lua_pushcclosure(L, debug_getupvalues, "debug.getupvalues", 0);
	lua_setfield(L, -2, "getupvalues");

	lua_pushcclosure(L, debug_setconstant, "debug.setconstant", 0);
	lua_setfield(L, -2, "setconstant");

	lua_pushcclosure(L, debug_setstack, "debug.setstack", 0);
	lua_setfield(L, -2, "setstack");

	lua_pushcclosure(L, debug_setupvalue, "debug.setupvalue", 0);
	lua_setfield(L, -2, "setupvalue");

	lua_pushcclosure(L, debug_getregistry, "debug.getregistry", 0);
	lua_setfield(L, -2, "getregistry");

	lua_setglobal(L, "debug");
}